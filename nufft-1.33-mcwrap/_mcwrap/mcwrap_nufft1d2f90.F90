!
!
! This file was auto-generated by MCWRAP
! https://github.com/magland/mcwrap
!
! You should not edit this file.
! You might not even want to read it.
! 
! 

#include "fintrf.h"

!====================================================================
!====================================================================

!     Gateway routine
subroutine mexFunction(nlhs, plhs, nrhs, prhs)

!     Declarations
      implicit none
      integer ii,jj
      mwSize numdims
      integer*4 dims(100)
      integer*4, ALLOCATABLE :: dims2(:)
      character*120 debug_line

!     mexFunction arguments:
      mwPointer plhs(*), prhs(*)
      integer nlhs, nrhs

!     Function declarations:
      mwPointer mxGetPr, mxGetPi
      mwPointer mxCreateNumericArray
      integer*4 mxClassIDFromClassName
      integer mxIsNumeric
      mwSize mxGetNumberOfDimensions
      mwPointer mxGetDimensions
      integer mcwrap_size

!CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
!     Declare inputs:
        !xj
        mwPointer p_input_xj
        real*8, ALLOCATABLE :: input_xj(:)
        !iflag
        mwPointer p_input_iflag
        Integer input_iflag
        real*8 input_iflag_double
        !eps
        mwPointer p_input_eps
        real*8 input_eps
        !fk
        mwPointer p_input_fk_re
        mwPointer p_input_fk_im
        real*8, ALLOCATABLE :: input_fk(:)
        real*8, ALLOCATABLE :: input_fk_re(:)
        real*8, ALLOCATABLE :: input_fk_im(:)

!     Declare outputs:
        !cj
        mwPointer p_output_cj_re
        mwPointer p_output_cj_im
        real*8, ALLOCATABLE :: output_cj(:)
        real*8, ALLOCATABLE :: output_cj_re(:)
        real*8, ALLOCATABLE :: output_cj_im(:)
        !ier
        mwPointer p_output_ier
        integer, ALLOCATABLE :: output_ier(:)
        real*8, ALLOCATABLE :: output_ier_double(:)

!     Declare set inputs:
        !nj
        integer input_nj
        !ms
        integer input_ms

      !call mexPrintf('test A'//char(10))
!-----Check the number of inputs/outputs
      if (nlhs==0) then
          nlhs=1
      end if
      if(nrhs .ne. 4) then
         call mexErrMsgIdAndTxt ('MCWRAP:IO','Incorrect number of inputs') 
      elseif(nlhs .gt. 2) then
         call mexErrMsgIdAndTxt ('MCWRAP:IO','Too many outputs.')
      endif


      !call mexPrintf('test A.2'//char(10))
!-----Setup the set inputs
        !nj
        input_nj=int(mcwrap_size(prhs(1),1))
        !ms
        input_ms=int(mcwrap_size(prhs(4),1))

    
      !call mexPrintf('test B'//char(10))
!-----Setup the inputs
        !xj
        !Check that we have the correct dimensions!
        numdims=mxGetNumberOfDimensions(prhs(1))
        if (numdims .gt. 2) then
          call mexErrMsgTxt('Incorrect number of dimensions in input: xj')
        end if
        call mxCopyPtrToInteger4(mxGetDimensions(prhs(1)),dims,numdims)
        ALLOCATE(dims2(2))
        dims2=(/ input_nj,1 /)
        do ii=1,2
          if (ii .le. numdims) then
              if (dims(ii) .ne. dims2(ii)) then
                call mexErrMsgTxt('Incorrect size of input: xj')
              end if
          else
            if (dims2(ii) .ne. 1) then
              call mexErrMsgTxt('Incorrect size of input (*): xj')
            end if
          end if;
        end do
        DEALLOCATE(dims2)
        p_input_xj=mxGetPr(prhs(1));
        ALLOCATE(input_xj((input_nj)*(1)))
        call mxCopyPtrToReal8(p_input_xj,input_xj,int((input_nj)*(1)))
        !iflag
        p_input_iflag=mxGetPr(prhs(2));
        call mxCopyPtrToReal8(p_input_iflag,input_iflag_double,1)
        input_iflag=int(input_iflag_double)
        !eps
        p_input_eps=mxGetPr(prhs(3));
        call mxCopyPtrToReal8(p_input_eps,input_eps,1)
        !fk
        !Check that we have the correct dimensions!
        numdims=mxGetNumberOfDimensions(prhs(4))
        if (numdims .gt. 2) then
          call mexErrMsgTxt('Incorrect number of dimensions in input: fk')
        end if
        call mxCopyPtrToInteger4(mxGetDimensions(prhs(4)),dims,numdims)
        ALLOCATE(dims2(2))
        dims2=(/ input_ms,1 /)
        do ii=1,2
          if (ii .le. numdims) then
              if (dims(ii) .ne. dims2(ii)) then
                call mexErrMsgTxt('Incorrect size of input: fk')
              end if
          else
            if (dims2(ii) .ne. 1) then
              call mexErrMsgTxt('Incorrect size of input (*): fk')
            end if
          end if;
        end do
        DEALLOCATE(dims2)
        p_input_fk_re=mxGetPr(prhs(4));
        p_input_fk_im=mxGetPi(prhs(4));
        ALLOCATE(input_fk((input_ms)*(1)*2))
        ALLOCATE(input_fk_re((input_ms)*(1)))
        ALLOCATE(input_fk_im((input_ms)*(1)))
        call mxCopyPtrToReal8(p_input_fk_re,input_fk_re,int((input_ms)*(1)))
        if (p_input_fk_im .NE. 0) then
            call mxCopyPtrToReal8(p_input_fk_im,input_fk_im,int((input_ms)*(1)))
        end if
        do ii=1,(input_ms)*(1)
            input_fk(1+(ii-1)*2)=input_fk_re(ii)
            if (p_input_fk_im .NE. 0) then
            input_fk(1+(ii-1)*2+1)=input_fk_im(ii)
            else
            input_fk(1+(ii-1)*2+1)=0    
            end if
        end do
    
      !call mexPrintf('test C'//char(10))
!-----Setup the outputs
        !cj
        if (1 .LE. nlhs) then
        if ((2 .lt. 1) .or. (2 .gt. 20)) then
          call mexErrMsgTxt ('Bad number of dimensions for my taste: 2') 
        end if
        ALLOCATE(dims2(2))
        dims2=(/ input_nj,1 /)
        do ii=1,2
            if ((dims2(ii) .lt. 1) .or. (dims2(ii) .gt. 10000000000.0)) then
              call mexErrMsgTxt ('Bad array size for my taste: input_nj,1') 
            end if
        end do
        DEALLOCATE(dims2)
        
            plhs(1)=mxCreateNumericArray(2,(/ input_nj,1 /),mxClassIDFromClassName('double'),1)
            p_output_cj_re=mxGetPr(plhs(1))
            p_output_cj_im=mxGetPi(plhs(1))
        end if
        ALLOCATE(output_cj(int((input_nj)*(1))*2))
        ALLOCATE(output_cj_re(int((input_nj)*(1))))
        ALLOCATE(output_cj_im(int((input_nj)*(1))))
        !ier
        if (2 .LE. nlhs) then
        if ((2 .lt. 1) .or. (2 .gt. 20)) then
          call mexErrMsgTxt ('Bad number of dimensions for my taste: 2') 
        end if
        ALLOCATE(dims2(2))
        dims2=(/ 1,1 /)
        do ii=1,2
            if ((dims2(ii) .lt. 1) .or. (dims2(ii) .gt. 10000000000.0)) then
              call mexErrMsgTxt ('Bad array size for my taste: 1,1') 
            end if
        end do
        DEALLOCATE(dims2)
        
            plhs(2)=mxCreateNumericArray(2,(/ 1,1 /),mxClassIDFromClassName('double'),0)
            p_output_ier=mxGetPr(plhs(2))
        end if
        ALLOCATE(output_ier(int((1)*(1))))
        ALLOCATE(output_ier_double(int((1)*(1))))

    
      !call mexPrintf('test D'//char(10))
!-----Run the subroutine
        call nufft1d2f90( &
        input_nj, &
        input_xj, &
        output_cj, &
        input_iflag, &
        input_eps, &
        input_ms, &
        input_fk, &
        output_ier &

        );
   
      !call mexPrintf('test E'//char(10))
!-----Free the inputs
        !xj
        DEALLOCATE(input_xj)
        !fk
        DEALLOCATE(input_fk)
        DEALLOCATE(input_fk_re)
        DEALLOCATE(input_fk_im)


      !call mexPrintf('test F'//char(10))
!-----Set the outputs
        !cj
        if (1 .LE. nlhs) then
            do ii=1,(input_nj)*(1)
                output_cj_re(ii)=output_cj(1+(ii-1)*2)
                output_cj_im(ii)=output_cj(1+(ii-1)*2+1)
            end do
            call mxCopyReal8ToPtr(output_cj_re,p_output_cj_re,int((input_nj)*(1)))
            call mxCopyReal8ToPtr(output_cj_im,p_output_cj_im,int((input_nj)*(1)))
        end if
        DEALLOCATE(output_cj)
        DEALLOCATE(output_cj_re)
        DEALLOCATE(output_cj_im)
        !ier
        if (2 .LE. nlhs) then
            do ii=1,(1)*(1)
                output_ier_double(ii)=output_ier(ii)
            end do
            call mxCopyReal8ToPtr(output_ier_double,p_output_ier,int((1)*(1)))
        end if
        DEALLOCATE(output_ier)
        DEALLOCATE(output_ier_double)


      !call mexPrintf('test G'//char(10))

!----- We are done -----!

        return
        end

    function mcwrap_size(X,j) result(ret)
        implicit none !important!!
        mwPointer X
        integer j
        integer*4 ret
        mwSize numdims
        integer*4 dims(100)
        mwSize mxGetNumberOfDimensions
        mwPointer mxGetDimensions
        
        numdims=mxGetNumberOfDimensions(X)
        if ((j .lt. 1) .or. (j .gt. numdims)) then
            ret=1
            return
        end if
        call mxCopyPtrToInteger4(mxGetDimensions(X),dims,numdims)
        ret=dims(j)
    end function mcwrap_size
