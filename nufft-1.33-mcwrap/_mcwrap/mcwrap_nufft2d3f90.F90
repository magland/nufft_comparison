!
!
! This file was auto-generated by MCWRAP
! https://github.com/magland/mcwrap
!
! You should not edit this file.
! You might not even want to read it.
! 
! 

#include "fintrf.h"

!====================================================================
!====================================================================

!     Gateway routine
subroutine mexFunction(nlhs, plhs, nrhs, prhs)

!     Declarations
      implicit none
      integer ii,jj
      mwSize numdims
      integer*4 dims(100)
      integer*4, ALLOCATABLE :: dims2(:)
      character*120 debug_line

!     mexFunction arguments:
      mwPointer plhs(*), prhs(*)
      integer nlhs, nrhs

!     Function declarations:
      mwPointer mxGetPr, mxGetPi
      mwPointer mxCreateNumericArray
      integer*4 mxClassIDFromClassName
      integer mxIsNumeric
      mwSize mxGetNumberOfDimensions
      mwPointer mxGetDimensions
      integer mcwrap_size

!CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
!     Declare inputs:
        !xj
        mwPointer p_input_xj
        real*8, ALLOCATABLE :: input_xj(:)
        !yj
        mwPointer p_input_yj
        real*8, ALLOCATABLE :: input_yj(:)
        !cj
        mwPointer p_input_cj_re
        mwPointer p_input_cj_im
        real*8, ALLOCATABLE :: input_cj(:)
        real*8, ALLOCATABLE :: input_cj_re(:)
        real*8, ALLOCATABLE :: input_cj_im(:)
        !iflag
        mwPointer p_input_iflag
        Integer input_iflag
        real*8 input_iflag_double
        !eps
        mwPointer p_input_eps
        real*8 input_eps
        !sk
        mwPointer p_input_sk
        real*8, ALLOCATABLE :: input_sk(:)
        !tk
        mwPointer p_input_tk
        real*8, ALLOCATABLE :: input_tk(:)

!     Declare outputs:
        !fk
        mwPointer p_output_fk_re
        mwPointer p_output_fk_im
        real*8, ALLOCATABLE :: output_fk(:)
        real*8, ALLOCATABLE :: output_fk_re(:)
        real*8, ALLOCATABLE :: output_fk_im(:)
        !ier
        mwPointer p_output_ier
        integer, ALLOCATABLE :: output_ier(:)
        real*8, ALLOCATABLE :: output_ier_double(:)

!     Declare set inputs:
        !nj
        integer input_nj
        !nk
        integer input_nk

      !call mexPrintf('test A'//char(10))
!-----Check the number of inputs/outputs
      if (nlhs==0) then
          nlhs=1
      end if
      if(nrhs .ne. 7) then
         call mexErrMsgIdAndTxt ('MCWRAP:IO','Incorrect number of inputs') 
      elseif(nlhs .gt. 2) then
         call mexErrMsgIdAndTxt ('MCWRAP:IO','Too many outputs.')
      endif


      !call mexPrintf('test A.2'//char(10))
!-----Setup the set inputs
        !nj
        input_nj=int(mcwrap_size(prhs(1),1))
        !nk
        input_nk=int(mcwrap_size(prhs(6),1))

    
      !call mexPrintf('test B'//char(10))
!-----Setup the inputs
        !xj
        !Check that we have the correct dimensions!
        numdims=mxGetNumberOfDimensions(prhs(1))
        if (numdims .gt. 2) then
          call mexErrMsgTxt('Incorrect number of dimensions in input: xj')
        end if
        call mxCopyPtrToInteger4(mxGetDimensions(prhs(1)),dims,numdims)
        ALLOCATE(dims2(2))
        dims2=(/ input_nj,1 /)
        do ii=1,2
          if (ii .le. numdims) then
              if (dims(ii) .ne. dims2(ii)) then
                call mexErrMsgTxt('Incorrect size of input: xj')
              end if
          else
            if (dims2(ii) .ne. 1) then
              call mexErrMsgTxt('Incorrect size of input (*): xj')
            end if
          end if;
        end do
        DEALLOCATE(dims2)
        p_input_xj=mxGetPr(prhs(1));
        ALLOCATE(input_xj((input_nj)*(1)))
        call mxCopyPtrToReal8(p_input_xj,input_xj,int((input_nj)*(1)))
        !yj
        !Check that we have the correct dimensions!
        numdims=mxGetNumberOfDimensions(prhs(2))
        if (numdims .gt. 2) then
          call mexErrMsgTxt('Incorrect number of dimensions in input: yj')
        end if
        call mxCopyPtrToInteger4(mxGetDimensions(prhs(2)),dims,numdims)
        ALLOCATE(dims2(2))
        dims2=(/ input_nj,1 /)
        do ii=1,2
          if (ii .le. numdims) then
              if (dims(ii) .ne. dims2(ii)) then
                call mexErrMsgTxt('Incorrect size of input: yj')
              end if
          else
            if (dims2(ii) .ne. 1) then
              call mexErrMsgTxt('Incorrect size of input (*): yj')
            end if
          end if;
        end do
        DEALLOCATE(dims2)
        p_input_yj=mxGetPr(prhs(2));
        ALLOCATE(input_yj((input_nj)*(1)))
        call mxCopyPtrToReal8(p_input_yj,input_yj,int((input_nj)*(1)))
        !cj
        !Check that we have the correct dimensions!
        numdims=mxGetNumberOfDimensions(prhs(3))
        if (numdims .gt. 2) then
          call mexErrMsgTxt('Incorrect number of dimensions in input: cj')
        end if
        call mxCopyPtrToInteger4(mxGetDimensions(prhs(3)),dims,numdims)
        ALLOCATE(dims2(2))
        dims2=(/ input_nj,1 /)
        do ii=1,2
          if (ii .le. numdims) then
              if (dims(ii) .ne. dims2(ii)) then
                call mexErrMsgTxt('Incorrect size of input: cj')
              end if
          else
            if (dims2(ii) .ne. 1) then
              call mexErrMsgTxt('Incorrect size of input (*): cj')
            end if
          end if;
        end do
        DEALLOCATE(dims2)
        p_input_cj_re=mxGetPr(prhs(3));
        p_input_cj_im=mxGetPi(prhs(3));
        ALLOCATE(input_cj((input_nj)*(1)*2))
        ALLOCATE(input_cj_re((input_nj)*(1)))
        ALLOCATE(input_cj_im((input_nj)*(1)))
        call mxCopyPtrToReal8(p_input_cj_re,input_cj_re,int((input_nj)*(1)))
        if (p_input_cj_im .NE. 0) then
            call mxCopyPtrToReal8(p_input_cj_im,input_cj_im,int((input_nj)*(1)))
        end if
        do ii=1,(input_nj)*(1)
            input_cj(1+(ii-1)*2)=input_cj_re(ii)
            if (p_input_cj_im .NE. 0) then
            input_cj(1+(ii-1)*2+1)=input_cj_im(ii)
            else
            input_cj(1+(ii-1)*2+1)=0    
            end if
        end do
        !iflag
        p_input_iflag=mxGetPr(prhs(4));
        call mxCopyPtrToReal8(p_input_iflag,input_iflag_double,1)
        input_iflag=int(input_iflag_double)
        !eps
        p_input_eps=mxGetPr(prhs(5));
        call mxCopyPtrToReal8(p_input_eps,input_eps,1)
        !sk
        !Check that we have the correct dimensions!
        numdims=mxGetNumberOfDimensions(prhs(6))
        if (numdims .gt. 2) then
          call mexErrMsgTxt('Incorrect number of dimensions in input: sk')
        end if
        call mxCopyPtrToInteger4(mxGetDimensions(prhs(6)),dims,numdims)
        ALLOCATE(dims2(2))
        dims2=(/ input_nk,1 /)
        do ii=1,2
          if (ii .le. numdims) then
              if (dims(ii) .ne. dims2(ii)) then
                call mexErrMsgTxt('Incorrect size of input: sk')
              end if
          else
            if (dims2(ii) .ne. 1) then
              call mexErrMsgTxt('Incorrect size of input (*): sk')
            end if
          end if;
        end do
        DEALLOCATE(dims2)
        p_input_sk=mxGetPr(prhs(6));
        ALLOCATE(input_sk((input_nk)*(1)))
        call mxCopyPtrToReal8(p_input_sk,input_sk,int((input_nk)*(1)))
        !tk
        !Check that we have the correct dimensions!
        numdims=mxGetNumberOfDimensions(prhs(7))
        if (numdims .gt. 2) then
          call mexErrMsgTxt('Incorrect number of dimensions in input: tk')
        end if
        call mxCopyPtrToInteger4(mxGetDimensions(prhs(7)),dims,numdims)
        ALLOCATE(dims2(2))
        dims2=(/ input_nk,1 /)
        do ii=1,2
          if (ii .le. numdims) then
              if (dims(ii) .ne. dims2(ii)) then
                call mexErrMsgTxt('Incorrect size of input: tk')
              end if
          else
            if (dims2(ii) .ne. 1) then
              call mexErrMsgTxt('Incorrect size of input (*): tk')
            end if
          end if;
        end do
        DEALLOCATE(dims2)
        p_input_tk=mxGetPr(prhs(7));
        ALLOCATE(input_tk((input_nk)*(1)))
        call mxCopyPtrToReal8(p_input_tk,input_tk,int((input_nk)*(1)))
    
      !call mexPrintf('test C'//char(10))
!-----Setup the outputs
        !fk
        if (1 .LE. nlhs) then
        if ((2 .lt. 1) .or. (2 .gt. 20)) then
          call mexErrMsgTxt ('Bad number of dimensions for my taste: 2') 
        end if
        ALLOCATE(dims2(2))
        dims2=(/ input_nk,1 /)
        do ii=1,2
            if ((dims2(ii) .lt. 1) .or. (dims2(ii) .gt. 10000000000.0)) then
              call mexErrMsgTxt ('Bad array size for my taste: input_nk,1') 
            end if
        end do
        DEALLOCATE(dims2)
        
            plhs(1)=mxCreateNumericArray(2,(/ input_nk,1 /),mxClassIDFromClassName('double'),1)
            p_output_fk_re=mxGetPr(plhs(1))
            p_output_fk_im=mxGetPi(plhs(1))
        end if
        ALLOCATE(output_fk(int((input_nk)*(1))*2))
        ALLOCATE(output_fk_re(int((input_nk)*(1))))
        ALLOCATE(output_fk_im(int((input_nk)*(1))))
        !ier
        if (2 .LE. nlhs) then
        if ((2 .lt. 1) .or. (2 .gt. 20)) then
          call mexErrMsgTxt ('Bad number of dimensions for my taste: 2') 
        end if
        ALLOCATE(dims2(2))
        dims2=(/ 1,1 /)
        do ii=1,2
            if ((dims2(ii) .lt. 1) .or. (dims2(ii) .gt. 10000000000.0)) then
              call mexErrMsgTxt ('Bad array size for my taste: 1,1') 
            end if
        end do
        DEALLOCATE(dims2)
        
            plhs(2)=mxCreateNumericArray(2,(/ 1,1 /),mxClassIDFromClassName('double'),0)
            p_output_ier=mxGetPr(plhs(2))
        end if
        ALLOCATE(output_ier(int((1)*(1))))
        ALLOCATE(output_ier_double(int((1)*(1))))

    
      !call mexPrintf('test D'//char(10))
!-----Run the subroutine
        call nufft2d3f90( &
        input_nj, &
        input_xj, &
        input_yj, &
        input_cj, &
        input_iflag, &
        input_eps, &
        input_nk, &
        input_sk, &
        input_tk, &
        output_fk, &
        output_ier &

        );
   
      !call mexPrintf('test E'//char(10))
!-----Free the inputs
        !xj
        DEALLOCATE(input_xj)
        !yj
        DEALLOCATE(input_yj)
        !cj
        DEALLOCATE(input_cj)
        DEALLOCATE(input_cj_re)
        DEALLOCATE(input_cj_im)
        !sk
        DEALLOCATE(input_sk)
        !tk
        DEALLOCATE(input_tk)


      !call mexPrintf('test F'//char(10))
!-----Set the outputs
        !fk
        if (1 .LE. nlhs) then
            do ii=1,(input_nk)*(1)
                output_fk_re(ii)=output_fk(1+(ii-1)*2)
                output_fk_im(ii)=output_fk(1+(ii-1)*2+1)
            end do
            call mxCopyReal8ToPtr(output_fk_re,p_output_fk_re,int((input_nk)*(1)))
            call mxCopyReal8ToPtr(output_fk_im,p_output_fk_im,int((input_nk)*(1)))
        end if
        DEALLOCATE(output_fk)
        DEALLOCATE(output_fk_re)
        DEALLOCATE(output_fk_im)
        !ier
        if (2 .LE. nlhs) then
            do ii=1,(1)*(1)
                output_ier_double(ii)=output_ier(ii)
            end do
            call mxCopyReal8ToPtr(output_ier_double,p_output_ier,int((1)*(1)))
        end if
        DEALLOCATE(output_ier)
        DEALLOCATE(output_ier_double)


      !call mexPrintf('test G'//char(10))

!----- We are done -----!

        return
        end

    function mcwrap_size(X,j) result(ret)
        implicit none !important!!
        mwPointer X
        integer j
        integer*4 ret
        mwSize numdims
        integer*4 dims(100)
        mwSize mxGetNumberOfDimensions
        mwPointer mxGetDimensions
        
        numdims=mxGetNumberOfDimensions(X)
        if ((j .lt. 1) .or. (j .gt. numdims)) then
            ret=1
            return
        end if
        call mxCopyPtrToInteger4(mxGetDimensions(X),dims,numdims)
        ret=dims(j)
    end function mcwrap_size
